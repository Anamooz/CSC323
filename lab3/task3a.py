import requests
from tools import *
from task2a import *
import html
from urllib.parse import quote
import hashlib


session = requests.Session()
NEW_POST_URL = "http://localhost:8080/post"


def preprocessing(message):
    # Pre-processing:
    # The message length in bits (always a multiple of the number of bits in a character).
    original_byte_len = len(message)

    # Get the number bits in the message
    original_bit_len = original_byte_len * 8

    # Add 1 to the end of the message
    message += b"\x80"

    # Pad the msg to 56 bytes (448
    # Last 8 bytes will be used to store the length of the original message)
    new_msg_len = (original_byte_len + 1) % 64
    message += b"\x00" * ((56 - new_msg_len) % 64)

    # Append the original message length in bits as a 64-bit big-endian integer
    message += int.to_bytes(original_bit_len, 8, "big")
    return message


def sha1(
    message, h0=0x67452301, h1=0xEFCDAB89, h2=0x98BADCFE, h3=0x10325476, h4=0xC3D2E1F0
):

    print("From SHA1 Hashing: ", message)

    message = preprocessing(message)

    # Process the message in successive 512-bit chunks:
    print("From SHA1 the length of the message", len(message))
    for i in range(0, len(message), 64):
        print("From SHA1 Loop", i, h0, h1, h2, h3, h4)
        h0, h1, h2, h3, h4 = sha1Helper(message, i, h0, h1, h2, h3, h4)

    # Produce the final hash value (big-endian) as a 160-bit number:
    # The final hash is a concatenation of the 5 32-bit hash values
    print("From SHA1 Tage [H0-H4]", h0, h1, h2, h3, h4)
    hh = (h0 << 128) | (h1 << 96) | (h2 << 64) | (h3 << 32) | h4
    return message, hh


def splittingTag(tag):
    hh = int(tag, 16)
    h4 = hh & 0xFFFFFFFF
    h3 = (hh >> 32) & 0xFFFFFFFF
    h2 = (hh >> 64) & 0xFFFFFFFF
    h1 = (hh >> 96) & 0xFFFFFFFF
    h0 = (hh >> 128) & 0xFFFFFFFF
    return h0, h1, h2, h3, h4


def parseHTML(string):
    return html.unescape(string)


# # Collect the hash value from the webserver
response = requests.get(NEW_POST_URL)
last_post = response.text.split("<div id='rowText'></div>")[-2]
og_msg = last_post.split("<div id='postContainer'>")[1].split("</div>")[0].strip()
tag = last_post.split("<div id='postFooter'>")[1].split("</div>")[0].strip()
member = (
    last_post.split('<b><font color="white">')[1].split(" says:</font></b>")[0].strip()
)
og_msg = parseHTML(og_msg)
print("Server MSG : ", og_msg)
print("From : ", member)
print("With tag: ", tag)


def checkTag(tag1, tag2):
    result = 0
    for x, y in zip(tag1, tag2):
        result |= x ^ y
    return result == 0


# mock_msg = "Hello, this is a test message".encode()
# key = "This is a 20 byte ky".encode()
# member = "Abbott"
# padded = preprocessing(key + mock_msg)
# og_tag = hex(sha1(key + mock_msg)[1])[2:]
# print("Og tag", og_tag)
# print(padded)

# extended_tag = hashlib.sha1(padded + "abc".encode()).hexdigest()
# print("Extended ", extended_tag)

# og_msg = mock_msg.decode()
# tag = og_tag

keyed_msg = (b"\x00" * 20) + og_msg.encode()
padded_msg = preprocessing(keyed_msg)

p = ((56 - (20 + len(og_msg))) % 64) + 8
# old_padding_bytes = padded[-p:]
padding_bytes = padded_msg[-p:]
print(p, padding_bytes)

# print("Padding from the server", old_padding_bytes)
print("Padding from us", padding_bytes)

extended_msg = padded_msg + "abc".encode()
extended_msg = preprocessing(extended_msg)

# print("Our tags ", *splittingTag(tag))
h0, h1, h2, h3, h4 = sha1Helper(extended_msg, 64, *splittingTag(tag))
print("Our new (before extension) tags H0-H4 ", h0, h1, h2, h3, h4)
hh = (h0 << 128) | (h1 << 96) | (h2 << 64) | (h3 << 32) | h4
print("Extracted tags are H0-H4", *splittingTag(hex(hh)[2:]))

print("HH is ", hh)
what_msg = quote(og_msg.encode() + padding_bytes + "abc".encode())
print("Submitting the hex tag", hex(hh)[2:], "with msg", what_msg)

# print(
#     "Comapring our tag to one generated by server",
#     "Server : ",
#     extended_tag,
#     "Our : ",
#     hex(hh)[2:],
# )

# print("Checking", checkTag(bytes.fromhex(hex(hh)[2:]), bytes.fromhex(extended_tag)))
SUBMIT_URL = f"http://localhost:8080/"
print("Submitting", SUBMIT_URL)


response = session.post(
    SUBMIT_URL, data={"who": member, "what": what_msg, "tag": hex(hh)[2:]}
)
if "Invalid signature" not in response.text:
    print("Success")
else:
    print("Failed")
# # Input h0 ... h4 to our state machine for the SHA1 algorithm


# # Think of a another msg; the extended msg < 512 bits

# # Calculate the hash value of the extended msg by calling SHA1

# # Send the new hash value to the webserver
